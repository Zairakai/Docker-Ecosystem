# Architecture Comparison: 3 Testing Modes

This document compares the three distinct architectural modes supported by the Zairakai Docker Ecosystem.

## Quick Reference Table

| Feature | Blade-only | SPA-only | Hybrid (Laravel + Vite) |
| ------- | ---------- | -------- | ----------------------- |
| **Frontend Framework** | None | Vue.js standalone | Vue.js in Laravel |
| **Rendering** | Server-side (PHP) | Client-side (JS) | Both |
| **Node.js Build** | Not needed | Required | Required |
| **Asset Location** | public/css, public/js | dist/ (separate) | public/build/ (Laravel) |
| **Backend** | Laravel (Blade views) | Laravel API only | Laravel (Blade + API) |
| **CORS** | Not needed | Required | Not needed |
| **Complexity** | Low | Medium | Medium |
| **Use Case** | Traditional web app | Modern SPA | Progressive enhancement |

## Mode 1: Blade-only (Pure SSR)

### Architecture Diagram

```txt
Browser
   ↓ HTTP Request
Nginx (port 80)
   ↓ Forward to PHP-FPM
PHP (Laravel)
   ↓ Render Blade template
HTML Response (complete page)
   ↓
Browser displays content
```

### Key Characteristics

- **No JavaScript framework**: Pure HTML generated by PHP
- **No build step**: CSS/JS (if any) served directly from public/
- **No Node.js container**: PHP only
- **Simple deployment**: Just PHP + Database

### Directory Structure

```bash
laravel/
├── resources/
│   └── views/              # Blade templates
│       ├── home.blade.php
│       └── about.blade.php
├── public/
│   ├── css/                # Plain CSS (no compilation)
│   │   └── app.css
│   ├── js/                 # Vanilla JS (no framework)
│   │   └── app.js
│   └── index.php
└── routes/
    └── web.php             # Web routes only
```

### Example Blade Template

```html
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="/css/app.css">
</head>
<body>
    <h1>Welcome, {{ $user->name }}</h1>

    <ul>
        @foreach($posts as $post)
            <li>{{ $post->title }}</li>
        @endforeach
    </ul>

    <script src="/js/app.js"></script>
</body>
</html>
```

### Testing

```bash
# No build step required
docker-compose -f examples/docker-compose-mode-blade.yml up

# Tests verify server-rendered HTML
# No JavaScript execution needed
```

### Gherkin Test Example

```gherkin
Scenario: Homepage displays user data
  Given I navigate to "http://nginx/"
  Then the HTML should contain "Welcome, John Doe"
  And the page should have a list with 5 posts
  # All content in HTML immediately, no JS needed
```

## Mode 2: SPA-only (Decoupled Architecture)

### Architecture Diagram

```txt
Browser
   ↓ HTTP Request "/"
Nginx (port 80)
   ↓ Serve static file
dist/index.html
   ↓ Browser loads Vue.js
Vue.js App starts
   ↓ API call "/api/users"
Nginx
   ↓ Proxy to PHP-FPM
PHP (Laravel API)
   ↓ JSON Response
Vue.js renders UI
```

### Key Characteristics

- **Completely decoupled**: Frontend and backend are separate projects
- **Vue.js standalone**: SPA built with Vite, served as static files
- **Laravel API only**: No Blade views, routes/api.php only
- **CORS required**: Cross-origin requests from SPA to API
- **Two separate codebases**: Vue.js app + Laravel API

### Directory Structure

```bash
# Separate projects
vuejs-app/                  # Vue.js SPA project
├── src/
│   ├── main.js
│   ├── App.vue
│   ├── components/
│   └── views/
├── public/
│   └── index.html
├── dist/                   # Build output (served by Nginx)
│   ├── index.html
│   └── assets/
│       ├── index-abc123.js
│       └── index-abc123.css
├── package.json
└── vite.config.js

laravel-api/                # Laravel API project
├── app/
│   └── Http/
│       └── Controllers/
│           └── Api/        # API controllers only
├── routes/
│   └── api.php            # API routes only (no web.php)
└── config/
    └── cors.php           # CORS configuration
```

### Vue.js App Structure

```javascript
// src/main.js
import { createApp } from 'vue'
import { createRouter } from 'vue-router'
import App from './App.vue'

const router = createRouter({
  routes: [
    { path: '/', component: Home },
    { path: '/users', component: Users }
  ]
})

const app = createApp(App)
app.use(router)
app.mount('#app')
```

### Laravel API Routes

```php
// routes/api.php
Route::middleware('api')
  ->controller(UserController::class)
  ->group(function () {
    Route::get('/users', 'index');
    Route::get('/users/{id}', 'show');
    Route::post('/users', 'store');
  });

// No web.php routes, API only
```

### Build & Testing Workflow

```bash
# Step 1: Build Vue.js SPA
docker-compose up node-build
# → npm run build
# → Output: vuejs-app/dist/index.html + assets

# Step 2: Test
docker-compose up nginx php-api e2e-testing
# Nginx serves dist/index.html
# Vue.js calls /api/* → PHP-FPM → Laravel API
```

### Nginx Configuration

```nginx
# Serve Vue.js static files
root /var/www/html/dist;

location / {
    try_files $uri /index.html;  # SPA client-side routing
}

# Proxy API calls to Laravel
location /api {
    fastcgi_pass php-api:9000;
    # CORS headers
    add_header 'Access-Control-Allow-Origin' '*';
}
```

### Gherkin Test Example

```gherkin
Scenario: SPA loads user list from API
  Given I navigate to "http://nginx/"
  When I wait for Vue.js to mount
  And I click on "Users" link
  Then the URL should be "http://nginx/users"
  And I should see a loading spinner
  When the API call to "/api/users" completes
  Then I should see 10 user cards
  # All content loaded via JavaScript + API
```

## Mode 3: Hybrid (Laravel + Vite Standard)

### Architecture Diagram

```txt
Browser
   ↓ HTTP Request "/"
Nginx (port 80)
   ↓ Forward to PHP-FPM
PHP (Laravel)
   ↓ Render Blade template
   ↓ @vite directive reads manifest.json
Blade HTML with <script src="/build/assets/app-abc123.js">
   ↓
Browser loads HTML (SSR content visible)
   ↓
Browser loads /build/assets/app-abc123.js
   ↓ PHP serves from public/build/
Vue.js mounts and hydrates components
```

### Key Characteristics

- **Best of both worlds**: Blade SSR + Vue.js components
- **Single codebase**: Laravel project with Vue.js inside
- **Vite integration**: Laravel official asset bundler
- **Progressive enhancement**: Start with Blade, add Vue.js where needed
- **Assets in Laravel**: Vue.js compiled to public/build/

### Directory Structure

```bash
laravel/
├── resources/
│   ├── views/              # Blade templates
│   │   └── dashboard.blade.php
│   ├── js/                 # Vue.js components
│   │   ├── app.js          # Entry point
│   │   └── Components/
│   │       └── Dashboard.vue
│   └── css/
│       └── app.css
├── public/
│   ├── build/              # Generated by Vite
│   │   ├── manifest.json
│   │   └── assets/
│   │       ├── app-abc123.js
│   │       └── app-abc123.css
│   └── index.php
├── routes/
│   ├── web.php             # Blade routes
│   └── api.php             # API routes for Vue.js
├── package.json            # Node.js dependencies
└── vite.config.js          # Vite configuration
```

### Blade Template with Vue.js

```html
<!DOCTYPE html>
<html>
<head>
    {{-- Vite directive automatically includes compiled assets --}}
    @vite(['resources/css/app.css', 'resources/js/app.js'])
</head>
<body>
    {{-- Server-rendered Blade content --}}
    <header>
        <h1>Welcome, {{ $user->name }}</h1>
    </header>

    {{-- Vue.js component mount point --}}
    <div id="app">
        <dashboard-component :user="{{ $user }}"></dashboard-component>
    </div>

    {{-- More Blade SSR content --}}
    <footer>
        <p>&copy; 2025</p>
    </footer>
</body>
</html>
```

Generated HTML:

```html
<head>
    <link rel="stylesheet" href="/build/assets/app-abc123.css">
    <script type="module" src="/build/assets/app-abc123.js"></script>
</head>
<body>
    <header>
        <h1>Welcome, John Doe</h1>  <!-- Immediate SSR content -->
    </header>
    <div id="app">
        <!-- Vue.js will mount here -->
    </div>
</body>
```

### Vue.js Component

```javascript
<!-- resources/js/Components/Dashboard.vue -->
<template>
  <div class="dashboard">
    <h2>Dashboard for {{ user.name }}</h2>
    <chart :data="chartData"></chart>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const props = defineProps(['user'])
const chartData = ref([])

onMounted(async () => {
  // Fetch dynamic data from Laravel API
  const res = await fetch('/api/dashboard/data')
  chartData.value = await res.json()
})
</script>
```

### Build & Testing Workflow

```bash
# Step 1: Build Vue.js assets into Laravel public/build/
docker-compose up node-build
# → npm install
# → npm run build
# → Output: public/build/manifest.json + assets/

# Step 2: Test
docker-compose up nginx php e2e-testing
# PHP serves everything from public/ including public/build/
```

### Gherkin Test Example

```gherkin
Scenario: Hybrid page with SSR and Vue.js
  Given I navigate to "http://nginx/dashboard"

  # Server-rendered content is immediate
  Then I should see "Welcome, John Doe" immediately
  And the header should be visible without JavaScript

  # Vue.js component loads after
  When I wait for Vue.js component "dashboard-component" to mount
  Then the dashboard chart should be visible
  And the chart should fetch data from "/api/dashboard/data"
  And the chart should be interactive
```

## Choosing the Right Mode

### Use Blade-only when:

- Building traditional server-rendered applications
- No need for complex JavaScript interactions
- Simplicity is priority
- SEO is critical and JS is not needed

### Use SPA-only when:

- Building modern app-like experiences
- Frontend team separate from backend team
- Need for offline capabilities (PWA)
- Complex client-side state management

### Use Hybrid when:

- Starting with Laravel, adding Vue.js progressively
- Need both SSR (SEO, initial load) and SPA (interactivity)
- Single team managing both frontend and backend
- Most common real-world Laravel + Vue.js setup

## Testing Strategy per Mode

| Aspect | Blade-only | SPA-only | Hybrid |
| ------ | ---------- | -------- | ------ |
| **HTML Structure** | Test immediately | Wait for Vue.js render | Test both SSR and Vue.js |
| **JavaScript** | Minimal or none | Essential | Progressive |
| **Wait Times** | Low | High (API + render) | Medium |
| **SEO Testing** | Direct HTML | Not applicable | SSR content only |
| **API Testing** | Not applicable | Via browser | Via browser |

## Performance Comparison

| Metric | Blade-only | SPA-only | Hybrid |
| ------ | ---------- | -------- | ------ |
| **Time to First Byte** | Fast | Fast (static) | Fast |
| **First Contentful Paint** | Fast | Slow | Fast (SSR) |
| **Time to Interactive** | Immediate | Slow | Medium |
| **Bundle Size** | Small | Large | Medium |
| **Server Load** | High | Low | Medium |

## Conclusion

All three modes are valid depending on your use case. The Docker ecosystem supports all three seamlessly with minimal configuration changes.
